# 提供された仕様（修正版）

## 基本仕様
- R(Red)は1、G(Green)は2、B(Blue)は3、Y(Yellow)は4、P(Purple)は5
- フィールド右下(field[12][5])がスタート地点
- field[12][5]とfield[12][4]が1つのペア、field[12][3]とfield[12][2]が1つのペア...、field[11][5]とfield[11][4]が1つのペア...のようにペアを作る
- 1つのペアが62進数の1文字で表されている
- 62進数を2進数に変換したときの右3bitがペアの右側(field[12][5]やfield[12][3]など)を表す
- 62進数を2進数に変換したときの左3bitがペアの左側(field[12][4]やfield[12][2]など)を表す

## **重要な修正：文字列は末尾から解釈する**
- エンコード文字列は**末尾から**処理する
- 最後の文字がfield[12][5]とfield[12][4]のペアを表す
- 最後から2番目の文字がfield[12][3]とfield[12][2]のペアを表す
- 以降、左へ2列ずつ移動し、行が終わったら上の行の右端から続ける

## 具体例

### 基本例
- 例えば"1"はfield[12][5]="R"かつfield[12][4]="."を表す
    - 1(001) + 0(000) = 1 の意味
- 例えば"2"はfield[12][5]="G"かつfield[12][4]="."を表す
    - 2(010) + 0(000) = 2 の意味
- 例えば"w"はfield[12][5]="."かつfield[12][4]="Y"を表す
    - 0(000) + 4(100) * 8 = 32 の意味

### 複数文字例（末尾から解釈）
- 例えば"1c"は...
    - "c"（末尾）→ field[12][5]="Y", field[12][4]="R"
    - "1"（末尾から2番目）→ field[12][3]="R", field[12][2]="."
    - 結果：field[12] = [..., ., R, R, Y] → "...RRY"

### 実装での解釈
- エンコード文字列を**逆順**で処理
- 62進数文字を10進数に変換
- 右3bit（decimal & 0b111）がペアの右側（列番号が大きい方）
- 左3bit（(decimal >> 3) & 0b111）がペアの左側（列番号が小さい方）
- フィールド配置は右下(12,5)から開始し、左へ2つずつ移動、行が終わったら上の行へ